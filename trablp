#include <stdio.h>
#include <stdlib.h>

typedef struct {
    void* end;
    int cont;
} ContatorReferencia;

static ContatorReferencia* references = NULL;
static int ContatorReferenciaSize = 0;

void* malloc2(size_t size) {
    void* end = malloc(size);

    if (end == NULL) {
        fprintf(stderr, "Erro: Falha na alocação de memória.\n");
        exit(1);
    }

    // Incrementa a contagem de referências
    ContatorReferencia* temp = realloc(references, sizeof(ContatorReferencia) * (ContatorReferenciaSize + 1));
    if (temp == NULL) {
        fprintf(stderr, "Erro: Falha na alocação de memória.\n");
        exit(1);
    }

    references = temp;
    references[ContatorReferenciaSize].end = end;
    references[ContatorReferenciaSize].cont = 1;
    ContatorReferenciaSize++;

    return end;
}

void atrib2(void** dest, void* src) {
    if (dest == NULL) {
        fprintf(stderr, "Erro: O destino é um ponteiro nulo.\n");
        exit(1);
    }

    // Decrementa a contagem de referências do ponteiro de destino atual
    if (*dest != NULL) {
        int i;
        for (i = 0; i < ContatorReferenciaSize; i++) {
            if (references[i].end == *dest) {
                references[i].cont--;

                // Verifica se a contagem de referências chegou a zero
                if (references[i].cont == 0) {
                    free(*dest);
                    references[i] = references[ContatorReferenciaSize - 1]; // Substitui pelo último elemento
                    ContatorReferenciaSize--;
                    references = realloc(references, sizeof(ContatorReferencia) * ContatorReferenciaSize); // Reduz o tamanho do array
                }

                break;
            }
        }
    }

    // Atribui o novo ponteiro de origem
    *dest = src;

    // Incrementa a contagem de referências do novo ponteiro de origem
    if (src != NULL) {
        int i;
        for (i = 0; i < ContatorReferenciaSize; i++) {
            if (references[i].end == src) {
                references[i].cont++;
                break;
            }
        }
    }

}

void Exibecont() {
    for (int i = 0; i < ContatorReferenciaSize; i++) {
        printf("Contador de referencias: %p = %d\n", references[i].end, references[i].cont);
    }
}

int main() {
    // Uso das funções do coletor automático de lixo

    // Alocação de memória usando malloc2
    int* ptr1 = (int*)malloc2(sizeof(int));
    *ptr1 = 10;
    
     int* ptr2 = (int*)malloc2(sizeof(int));
    *ptr2 = 40;
    
     int* ptr3 = (int*)malloc2(sizeof(int));
    *ptr3 = 50;

    int* ptr4 = NULL;
    atrib2((void**)&ptr4, ptr1);
    
    int*ptr5 = NULL;
    atrib2((void**)&ptr5,ptr1);
    
    int*ptr6 = NULL;
    atrib2((void**)&ptr6,ptr1);
    
	int*ptr7 = NULL;
    atrib2((void**)&ptr7,ptr1);
    
    atrib2((void**)&ptr2,ptr1);

    printf("Coletor automatico de lixo:\n");
    printf("ptr1: %d\n", *ptr1);
    printf("ptr2: %d\n", *ptr2);
    printf("ptr3: %d\n", *ptr3);
    printf("ptr4: %d\n", *ptr4);
    printf("ptr5: %d\n", *ptr5);
    printf("ptr6: %d\n", *ptr6);
    printf("ptr7: %d\n", *ptr7);
    Exibecont();
   

    return 0;
}
